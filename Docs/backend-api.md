# Backend API Service

This document defines the core requirements, features, and architectural decisions for the primary API service (`packages/api/`), built using Django and Django REST Framework (DRF). The service is designed for modularity, high developer experience, and production readiness.

---

## 1. Core Technical Stack

| Area              | Component                         | Note                                                                |
| :---------------- | :-------------------------------- | :------------------------------------------------------------------ |
| **Framework**     | Django                            | Recommended backend framework.                                      |
| **API**           | Django REST Framework (DRF)       | Standard for building REST APIs on Django.                          |
| **Database**      | PostgreSQL                        | Primary persistence layer, managed via Django ORM.                  |
| **Documentation** | **`drf-spectacular`** + **ReDoc** | Automatic OpenAPI 3.0 generation paired with a modern rendering UI. |

---

## 2. Core Backend Feature Requirements

These features are essential for a production-ready application and should be configured and enabled by default in the API service.

- **API Service:** Acts as the central REST/GraphQL endpoint for all clients (Web, iOS, Android).
- **Database Migrations:** Schema changes must be managed through code using the Django ORM's migration system.
- **API Rate Limiting:** A default, sensible rate-limiting policy must be configured globally to prevent abuse.
- **Email Integration:** Configured to support transactional email via **Django-Anymail**. Provider selection (e.g., Resend, Postmark, SendGrid) must be handled entirely through environment variables, requiring no code changes.

---

## 3. API Documentation Strategy: `drf-spectacular` + ReDoc

To deliver high-quality, auto-generated, and visually impressive documentation, the following strategy will be used:

### A. Automatic Schema Generation

- **Tool:** **`drf-spectacular`**
- **Function:** Automatically introspects your Django REST Framework code (Views, Serializers, ViewSets, URL patterns) to generate an accurate, up-to-spec **OpenAPI 3.0** JSON/YAML file.
- **Benefit:** Ensures the documentation stays synchronized with the code, eliminating manual documentation maintenance overhead.

### B. Documentation Presentation

- **Renderer:** **ReDoc**
- **Function:** Uses the OpenAPI file generated by `drf-spectacular` to render the interactive, single-page, three-panel reference documentation.
- **Goal:** Provides a superior aesthetic and user experience compared to the default Swagger UI.

### C. Implementation Overview

1. **Installation:** Install `drf-spectacular` in the backend project.
2. **Configuration:** Add `drf_spectacular` to `INSTALLED_APPS` and configure metadata (title, version) in `settings.py`.
3. **URL Setup:** Add the following endpoints to your main `urls.py`:
   - **Schema Endpoint:** An endpoint to serve the raw OpenAPI JSON file (e.g., `/api/schema/`).
   - **ReDoc UI Endpoint:** An endpoint that loads the ReDoc template, pointing it to the schema (e.g., `/api/docs/`).

### D. Activation / Deactivation Strategy

Following the project's modularity principle, documentation endpoints should be easy to disable in production environments where they might expose internal information or consume resources.

1. **Environment Variable Toggle:** Use an environment variable, such as `API_DOCS_ENABLED`, to control the URL inclusion.

   ```python
   # packages/api/urls.py (Conceptual)
   from django.urls import path, include
   from drf_spectacular.views import SpectacularAPIView, SpectacularRedocView
   import os

   urlpatterns = [
       # ... other API routes ...
   ]

   if os.environ.get('API_DOCS_ENABLED', 'False').lower() == 'true':
       urlpatterns += [
           # The URL to the raw OpenAPI schema (used by the frontend)
           path('api/schema/', SpectacularAPIView.as_view(), name='schema'),
           
           # The URL to the beautiful ReDoc UI
           path('api/docs/', SpectacularRedocView.as_view(url_name='schema'), name='redoc'),
       ]
   ```

2. **Helm Value Guard (Recommended for Kubernetes):** In your `charts/api/values.yaml`, define a toggle:

   ```yaml
   # charts/api/values.yaml
   api:
       # ... other config ...
       docs:
           enabled: true
           # This env var will be passed to the API container
           env_var: "API_DOCS_ENABLED"
   ```

   You would then inject this as an environment variable into the API Deployment manifest, ensuring documentation is only available when explicitly enabled via Helm values.

---

## 4. Optional Backend Features

These features can be enabled based on project requirements:

### 4.1 Worker Processes (Celery)

**Purpose:** Running background jobs asynchronously (e.g., sending emails, processing uploads, generating reports).

**Technology:** Celery with Redis or RabbitMQ as the message broker.

**Use Cases:**
- Sending emails asynchronously to avoid blocking API responses.
- Processing file uploads (image resizing, document parsing).
- Scheduled tasks (daily reports, cleanup jobs).

**Activation Strategy:**
- Enable via Helm values: `worker.enabled: true`
- Deploy as a separate Kubernetes Deployment.

### 4.2 Real-time Communication (WebSockets)

**Purpose:** Persistent, bidirectional connections for live updates.

**Technology:** Django Channels with Redis channel layer.

**Use Cases:**
- Live notifications
- Chat applications
- Collaborative editing
- Real-time dashboards

**Activation Strategy:**
- Enable via feature flag: `WEBSOCKETS_ENABLED=true`
- Deploy WebSocket server as separate service (can share codebase with API).

### 4.3 Object Storage Integration

**Purpose:** Storing and serving user-uploaded files (images, documents, videos).

**Technology:** S3-compatible storage (AWS S3, MinIO, DigitalOcean Spaces).

**Implementation:** Use `django-storages` with boto3.

**Best Practice:** Generate pre-signed URLs for direct client uploads/downloads to reduce server load.

**Service Authentication:** Require TLS everywhere. Issue service certificates via cluster cert-manager so frontend-to-backend traffic (including WebSockets) uses mTLS when deployed inside the cluster or through the ingress.

### 4.4 Authentication & Authorization

**Options:**
1. **Django's built-in auth** + JWT tokens (via `djangorestframework-simplejwt`)
2. **OAuth2/OIDC** integration with external providers (Keycloak, Auth0, Google, GitHub)
3. **Social authentication** via `django-allauth`

**Recommendation:** Start with JWT tokens for API authentication, add OAuth2 integration as needed.

### 4.5 Feature Flag Integration

**Purpose:** Toggle features at runtime without code deployments.

**Options:**
- **LaunchDarkly** (commercial)
- **Unleash** (open-source)
- **Django-flags** (simple, database-backed)

**Use Cases:**
- Gradual feature rollout
- A/B testing
- Emergency feature disable

---

## 5. Customer-Facing API Template

Provide a built-in, opinionated template for customer-facing API endpoints to ensure consistency, stability, and excellent developer experience.

Contract guidelines:

- Versioning: prefix routes with a version (e.g., `/api/v1/...`) and avoid breaking changes within a major version.
- Authentication: support API keys and/or OAuth2 (client credentials) for service integrations; JWT for first-party apps.
- Pagination: cursor- or page-based pagination with standard query params and response metadata (`next`, `prev`, `total` when applicable).
- Filtering & sorting: predictable query parameters (`filter[field]=`, `sort=field,-other`) with documented allowlists.
- Errors: structured errors using RFC 7807 Problem Details or a consistent envelope with machine-readable codes.
- Idempotency: support an `Idempotency-Key` header for safe retries on POST/PUT operations.
- Rate limiting: include standard headers (e.g., `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `Retry-After`).

Example shapes (illustrative):

```http
GET /api/v1/customers?cursor=eyJvZmZzZXQiOjEwMH0=&filter[status]=active&sort=-created_at
Authorization: Bearer <token>
```

```json
{
    "data": [ { "id": "cust_123", "email": "a@example.com", "status": "active" } ],
    "meta": { "next": "eyJvZmZzZXQiOjIwMH0=", "prev": null, "total": 1024 }
}
```

```http
POST /api/v1/invoices
Idempotency-Key: 7ad2b6c1-0e6f-4ac3-9c0a-1a2b3c4d5e6f
Content-Type: application/json

{"customer_id":"cust_123","items":[{"sku":"sku_1","qty":2}]}
```

```json
{
    "id": "inv_789",
    "status": "pending",
    "created_at": "2025-11-01T10:00:00Z"
}
```

OpenAPI documentation:

- Provide reusable components (schemas, parameters, responses) for pagination, errors, and common headers.
- Tag endpoints by domain (e.g., Customers, Invoices) and include example requests/responses.

Security & multi-tenancy:

- Enforce tenant scoping at the data layer and in queries.
- Log sensitive operations and surface correlation IDs for support.

Refer to this template when adding new public/customer endpoints to keep APIs consistent and easy to integrate.

## 6. Admin Endpoints & RBAC

Admin functionality must be exposed via dedicated, restricted API endpoints consumed by the Admin Portal webapp.

Requirements:

- Authorization: enforce admin-only access via RBAC (e.g., Django groups/permissions or role claims in JWT/OIDC tokens). Deny by default.
- Auditing: record who invoked an admin action, when, and with what parameters and outcome. Store audit logs in an append-only fashion where feasible.
- Rate limiting: apply conservative throttles distinct from public endpoints to prevent abuse.
- Idempotency and safety: design write endpoints to be idempotent where possible; prefer explicit, narrowly scoped operations over generic commands.
- CSRF and headers: for browser-based flows, ensure CSRF protection and strict security headers when accessed via the admin host/path.

Example endpoint categories (illustrative):

- Metrics & summaries: `/admin/metrics/...` for high-level stats surfaced in the portal.
- Job control: `/admin/jobs/...` to enqueue maintenance tasks or retries subject to permission checks.
- Feature management: `/admin/features/...` to toggle or configure feature flags in a controlled way.

Document and version admin endpoints alongside the public API, but host them under a separate URL namespace to simplify firewalling and routing.

## 7. References

- [Django Documentation](https://docs.djangoproject.com/)
- [Django REST Framework](https://www.django-rest-framework.org/)
- [drf-spectacular Documentation](https://drf-spectacular.readthedocs.io/)
- [ReDoc](https://redocly.com/redoc)
- [Django-Anymail](https://anymail.dev/)
- [Celery Documentation](https://docs.celeryq.dev/)
- [Django Channels](https://channels.readthedocs.io/)
