name: Sync Docs to Wiki

on:
  push:
    branches: [ main ]
    paths:
      - 'Docs/**'
      - '.github/workflows/wiki-sync.yml'
  workflow_dispatch:

jobs:
  sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # needed for pushing to the wiki repo
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare staging area
        run: |
          set -euo pipefail
          rm -rf wiki-stage
          mkdir -p wiki-stage

          # Copy Docs/ into staging and normalize
          rsync -av --delete Docs/ wiki-stage/

          # Map repo Docs/main.md to wiki Home.md if present
          if [ -f wiki-stage/main.md ]; then mv -f wiki-stage/main.md "wiki-stage/Home.md"; fi
          # Generate _Sidebar.md with:
          #  - Custom ordering via numeric prefixes (e.g., 01-intro.md)
          #  - Nested folders with indentation
          #  - Optional manual override: if Docs/_Sidebar.md exists, it will be synced as-is

          # If a manual _Sidebar.md exists in Docs/, keep it (copied by rsync). Otherwise, auto-generate.
          if [ ! -f wiki-stage/_Sidebar.md ]; then
            sidebar_tmp="wiki-stage/_Sidebar.md"

            strip_prefix() {
              # prints two fields: number_or_999999 and remainder
              local name="$1"
              if echo "$name" | grep -E '^[0-9]+[._-]'; then
                local num=$(echo "$name" | sed -E 's/^([0-9]+)[._-].*/\1/')
                local rest=$(echo "$name" | sed -E 's/^[0-9]+[._-]+//')
                printf '%s\t%s\n' "$num" "$rest"
              else
                printf '999999\t%s\n' "$name"
              fi
            }

            titleize() {
              # turn 'folder_structure.md' -> 'Folder Structure'
              echo "$1" | sed -E 's/\.md$//' | sed -E 's/[-_]+/ /g' | awk '{for(i=1;i<=NF;i++){ $i=toupper(substr($i,1,1)) substr($i,2) }}1'
            }

            rel_no_ext() {
              # make path relative to wiki root without .md extension
              echo "$1" | sed -E 's/^wiki-stage\///' | sed -E 's/\.md$//'
            }

            emit_dir() {
              local dir="$1"
              local indent="$2"
              # List directories and files, compute sort keys from numeric prefixes
              # Collect directories
              mapfile -t DIRS < <(find "$dir" -maxdepth 1 -mindepth 1 -type d -printf '%f\n' 2>/dev/null | while read -r d; do
                # skip hidden and underscore-prefixed folders
                [ "${d#_}" != "$d" ] && continue
                read -r num rest < <(strip_prefix "$d")
                printf '%s|D|%s|%s\n' "$num" "$rest" "$d"
              done | sort -t '|' -k1,1n -k3,3f)

              # Collect files and de-duplicate by base name preferring lowest numeric prefix
              mapfile -t FILES_RAW < <(find "$dir" -maxdepth 1 -mindepth 1 -type f -name '*.md' -printf '%f\n' 2>/dev/null | while read -r f; do
                # skip special files
                [ "$f" = "_Sidebar.md" ] && continue
                [ "$f" = "Home.md" ] && continue
                [ "${f#_}" != "$f" ] && continue
                read -r num rest < <(strip_prefix "$f")
                printf '%s|%s|%s\n' "$num" "$rest" "$f"
              done)
              # Build associative array: best[file_base]=num|filename (lowest num wins)
              declare -A BEST
              for entry in "${FILES_RAW[@]}"; do
                IFS='|' read -r num rest name <<< "$entry"
                key="$rest"
                if [[ -z "${BEST[$key]}" ]]; then
                  BEST[$key]="$num|$name"
                else
                  IFS='|' read -r best_num best_name <<< "${BEST[$key]}"
                  if (( 10#$num < 10#$best_num )); then
                    BEST[$key]="$num|$name"
                  fi
                fi
              done
              FILES=()
              for key in "${!BEST[@]}"; do
                IFS='|' read -r num name <<< "${BEST[$key]}"
                # Keep original 'rest' for display from key
                FILES+=("$num|F|$key|$name")
              done
              # Sort by numeric then display key
              IFS=$'\n' FILES=($(printf "%s\n" "${FILES[@]}" | sort -t '|' -k1,1n -k3,3f)); unset IFS

              # Emit directories first
              for entry in "${DIRS[@]}"; do
                IFS='|' read -r _ _ rest name <<< "$entry"
                local display=$(titleize "$rest")
                echo "${indent}- ${display}" >> "$sidebar_tmp"
                emit_dir "$dir/$name" "${indent}  "
              done

              # Then files
              for entry in "${FILES[@]}"; do
                IFS='|' read -r _ _ rest name <<< "$entry"
                local display=$(titleize "$rest")
                local link=$(rel_no_ext "$dir/$name")
                echo "${indent}- [${display}](${link})" >> "$sidebar_tmp"
              done
            }

            # Start sidebar with Home
            echo "- [[Home]]" > "$sidebar_tmp"
            emit_dir "wiki-stage" ""
          fi

          echo "---- Staged files (wiki-stage) ----"
          ls -la wiki-stage || true
          echo
          echo "Markdown files detected:"
          find wiki-stage -type f -name '*.md' -print | sed 's/^/  - /'
          echo
          if ! find wiki-stage -type f -name '*.md' | grep -q .; then
            echo "No markdown files found in Docs/. Ensure Docs/ contains .md files on the main branch."
            exit 1
          fi

      - name: Push to Wiki
        env:
          REPO: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # If GITHUB_TOKEN is restricted for the Wiki in your org, create a PAT and add as WIKI_PUSH_TOKEN secret,
          # then swap the clone URL below to use it instead of GITHUB_TOKEN.
          # WIKI_PUSH_TOKEN: ${{ secrets.WIKI_PUSH_TOKEN }}
        run: |
          set -euo pipefail
          git config --global init.defaultBranch main
          git config --global user.name  "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Check if the Wiki feature is enabled on this repository; if not, skip gracefully
          API_URL="${GITHUB_API_URL:-https://api.github.com}"
          if ! curl -fsSL -H "Authorization: Bearer ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" \
               "${API_URL}/repos/${REPO}" | grep -q '"has_wiki": *true'; then
            echo "Wiki feature is disabled for ${REPO}. Failing this job to make the requirement explicit."
            echo "Enable Wikis in Repo Settings → General → Features, then re-run."
            exit 1
          fi

          # Ensure a clean clone target to avoid residual directories across runs
          rm -rf wiki

          # Clone the wiki repository (separate .wiki repo)
          git clone "https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO}.wiki.git" wiki || {
            echo "Failed to clone wiki repository. Verify the wiki exists (create the first page) and token has access." >&2
            echo "Tip: Open the Wiki tab in GitHub and create an initial page to initialize the .wiki repo."
            exit 1
          }
          # If using PAT instead, use the following line and comment out the one above:
          # git clone "https://${WIKI_PUSH_TOKEN}@github.com/${REPO}.wiki.git" wiki

          # Sync staged content into wiki repo (delete removed files), but never touch .git
          rsync -av --delete --exclude '.git/' wiki-stage/ wiki/

          cd wiki
          echo "---- Wiki repo status before commit ----"
          git status --porcelain=v1
          if [ -z "$(git status --porcelain)" ]; then
            echo "No changes to commit."
            exit 0
          fi
          git add -A
          git commit -m "Sync Docs/ to Wiki [CI]"
          git push
          echo "Last wiki commit:" && git --no-pager log -1 --oneline

      - name: Cleanup workspace artifacts
        if: always()
        run: |
          rm -rf wiki-stage wiki || true
