name: Sync Docs to Wiki

on:
  push:
    branches: [ main ]
    paths:
      - 'Docs/**'
      - '.github/workflows/wiki-sync.yml'
  workflow_dispatch:

jobs:
  sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # needed for pushing to the wiki repo
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare staging area
        run: |
          set -euo pipefail
          rm -rf wiki-stage
          mkdir -p wiki-stage

          # Copy Docs/ into staging and normalize
          rsync -av --delete Docs/ wiki-stage/

          # Map repo Docs/main.md to wiki Home.md if present
          if [ -f wiki-stage/main.md ]; then mv -f wiki-stage/main.md "wiki-stage/Home.md"; fi
          # Generate _Sidebar.md with:
          #  - Custom ordering via numeric prefixes (e.g., 01-intro.md)
          #  - Nested folders with indentation
          #  - Optional manual override: if Docs/_Sidebar.md exists, it will be synced as-is

          # If a manual _Sidebar.md exists in Docs/, keep it (copied by rsync). Otherwise, auto-generate.
          if [ ! -f wiki-stage/_Sidebar.md ]; then
            sidebar_tmp="wiki-stage/_Sidebar.md"

            strip_prefix() {
              # prints two fields: number_or_999999 and remainder
              local name="$1"
              if echo "$name" | grep -E '^[0-9]+[._-]'; then
                local num=$(echo "$name" | sed -E 's/^([0-9]+)[._-].*/\1/')
                local rest=$(echo "$name" | sed -E 's/^[0-9]+[._-]+//')
                printf '%s\t%s\n' "$num" "$rest"
              else
                printf '999999\t%s\n' "$name"
              fi
            }

            titleize() {
              # turn 'folder_structure.md' -> 'Folder Structure'
              echo "$1" | sed -E 's/\.md$//' | sed -E 's/[-_]+/ /g' | awk '{for(i=1;i<=NF;i++){ $i=toupper(substr($i,1,1)) substr($i,2) }}1'
            }

            rel_no_ext() {
              # make path relative to wiki root without .md extension
              echo "$1" | sed -E 's/^wiki-stage\///' | sed -E 's/\.md$//'
            }

            emit_dir() {
              local dir="$1"
              local indent="$2"
              shopt -s nullglob
              local entries=()
              # Directories
              for full in "$dir"/*/; do
                local name="${full%/}"
                name="${name##*/}"
                [[ "$name" == _* ]] && continue
                local num rest
                if [[ "$name" =~ ^([0-9]+)[._-]+(.*)$ ]]; then
                  num="${BASH_REMATCH[1]}"; rest="${BASH_REMATCH[2]}"
                else
                  num=999999; rest="$name"
                fi
                entries+=("$num|D|$rest|$name")
              done
              # Files (dedupe by base name, prefer lowest numeric prefix)
              declare -A BEST=()
              for full in "$dir"/*.md; do
                local f="${full##*/}"
                [[ "$f" == "_Sidebar.md" || "$f" == "Home.md" || "$f" == _* ]] && continue
                local num rest
                if [[ "$f" =~ ^([0-9]+)[._-]+(.*)$ ]]; then
                  num="${BASH_REMATCH[1]}"; rest="${BASH_REMATCH[2]}"
                else
                  num=999999; rest="$f"
                fi
                if [[ -z "${BEST[$rest]+x}" || 10#$num -lt 10#${BEST[$rest]%%|*} ]]; then
                  BEST["$rest"]="$num|$f"
                fi
              done
              for key in "${!BEST[@]}"; do
                local pair="${BEST[$key]}"
                local num="${pair%%|*}"
                local name="${pair#*|}"
                entries+=("$num|F|$key|$name")
              done
              # Sort and emit
              if ((${#entries[@]})); then
                IFS=$'\n' read -r -d '' -a sorted < <(printf "%s\n" "${entries[@]}" | sort -t '|' -k1,1n -k2,2 -k3,3f && printf '\0')
                unset IFS
                for entry in "${sorted[@]}"; do
                  IFS='|' read -r num type rest name <<< "$entry"
                  if [[ "$type" == "D" ]]; then
                    local display=$(titleize "$rest")
                    echo "${indent}- ${display}" >> "$sidebar_tmp"
                    emit_dir "$dir/$name" "${indent}  "
                  else
                    local display=$(titleize "$rest")
                    local link=$(rel_no_ext "$dir/$name")
                    echo "${indent}- [${display}](${link})" >> "$sidebar_tmp"
                  fi
                done
              fi
            }

            # Start sidebar with Home
            echo "- [[Home]]" > "$sidebar_tmp"
            emit_dir "wiki-stage" ""
          fi

          echo "---- Staged files (wiki-stage) ----"
          ls -la wiki-stage || true
          echo
          echo "Markdown files detected:"
          find wiki-stage -type f -name '*.md' -print | sed 's/^/  - /'
          echo
          if ! find wiki-stage -type f -name '*.md' | grep -q .; then
            echo "No markdown files found in Docs/. Ensure Docs/ contains .md files on the main branch."
            exit 1
          fi

      - name: Push to Wiki
        env:
          REPO: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # If GITHUB_TOKEN is restricted for the Wiki in your org, create a PAT and add as WIKI_PUSH_TOKEN secret,
          # then swap the clone URL below to use it instead of GITHUB_TOKEN.
          # WIKI_PUSH_TOKEN: ${{ secrets.WIKI_PUSH_TOKEN }}
        run: |
          set -euo pipefail
          git config --global init.defaultBranch main
          git config --global user.name  "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Check if the Wiki feature is enabled on this repository; if not, skip gracefully
          API_URL="${GITHUB_API_URL:-https://api.github.com}"
          if ! curl -fsSL -H "Authorization: Bearer ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" \
               "${API_URL}/repos/${REPO}" | grep -q '"has_wiki": *true'; then
            echo "Wiki feature is disabled for ${REPO}. Failing this job to make the requirement explicit."
            echo "Enable Wikis in Repo Settings → General → Features, then re-run."
            exit 1
          fi

          # Ensure a clean clone target to avoid residual directories across runs
          rm -rf wiki

          # Clone the wiki repository (separate .wiki repo)
          git clone "https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO}.wiki.git" wiki || {
            echo "Failed to clone wiki repository. Verify the wiki exists (create the first page) and token has access." >&2
            echo "Tip: Open the Wiki tab in GitHub and create an initial page to initialize the .wiki repo."
            exit 1
          }
          # If using PAT instead, use the following line and comment out the one above:
          # git clone "https://${WIKI_PUSH_TOKEN}@github.com/${REPO}.wiki.git" wiki

          # Sync staged content into wiki repo (delete removed files), but never touch .git
          rsync -av --delete --exclude '.git/' wiki-stage/ wiki/

          cd wiki
          echo "---- Wiki repo status before commit ----"
          git status --porcelain=v1
          if [ -z "$(git status --porcelain)" ]; then
            echo "No changes to commit."
            exit 0
          fi
          git add -A
          git commit -m "Sync Docs/ to Wiki [CI]"
          git push
          echo "Last wiki commit:" && git --no-pager log -1 --oneline

      - name: Cleanup workspace artifacts
        if: always()
        run: |
          rm -rf wiki-stage wiki || true
