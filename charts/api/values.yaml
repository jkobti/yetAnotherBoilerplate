# Default values for api chart.
# These can be overridden via --values or --set.

# Global enable flag for the entire deployment
enabled: true

# Container image configuration
image:
  # Repository for the backend API image
  # For local development: yetanotherboilerplate/api
  # For production: ghcr.io/jkobti/yetanotherboilerplate/api
  repository: yetanotherboilerplate/api
  # Image tag or sha
  tag: dev
  # Image pull policy: IfNotPresent (local), Always (registry)
  pullPolicy: IfNotPresent

# Number of replicas
replicaCount: 1

# Kubernetes Service configuration
service:
  type: ClusterIP
  port: 8000

# Pod-level annotations (e.g., for Prometheus scraping)
podAnnotations: {}

# Prometheus ServiceMonitor configuration
serviceMonitor:
  enabled: false
  # Namespace where the ServiceMonitor should be installed (defaults to Release.Namespace)
  # namespace: observability
  # Labels to match the Prometheus serviceMonitorSelector
  # labels:
  #   release: prometheus
  interval: 30s
  scrapeTimeout: 10s
  path: /metrics

# PrometheusRule configuration
prometheusRule:
  enabled: false
  # Namespace where the PrometheusRule should be installed (defaults to Release.Namespace)
  # namespace: observability
  # Labels to match the Prometheus ruleSelector
  # labels:
  #   release: prometheus
  rules: []
    # - alert: ApiHighErrorRate
    #   expr: rate(http_requests_total{status=~"5.."}[5m]) > 0
    #   for: 1m
    #   labels:
    #     severity: critical
    #   annotations:
    #     summary: High error rate on API

# Resource requests and limits
resources:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 500m
    memory: 512Mi

# Ingress configuration (disabled by default; enable for external routing)
ingress:
  enabled: false
  className: nginx
  # Annotations for cert-manager integration (cert-manager.io/cluster-issuer)
  # For local: comment out or use cert-manager.io/cluster-issuer: local-selfsigned
  # For staging: cert-manager.io/cluster-issuer: letsencrypt-staging
  # For production: cert-manager.io/cluster-issuer: letsencrypt-prod
  annotations: {}
    # cert-manager.io/cluster-issuer: letsencrypt-staging
  # Hostnames and paths for this Ingress
  hosts:
    - host: api.local.dev
      paths:
        - path: /
          pathType: Prefix
  # TLS configuration (disabled by default; enable with cert-manager)
  tls: []
    # - secretName: api-tls
    #   hosts:
    #     - api.local.dev

# Horizontal Pod Autoscaler configuration (disabled by default)
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 3
  targetCPUUtilizationPercentage: 70

# Standard Kubernetes labels
labels:
  app.kubernetes.io/part-of: yetanotherboilerplate
  app.kubernetes.io/component: api

# Image pull secrets for private registries
imagePullSecrets: []

# Node scheduling constraints
nodeSelector: {}

# Pod tolerations (e.g., for taints)
tolerations: []

# Secret management configuration
# Secrets are injected via environment variables or volume mounts.
# For local development: create Kubernetes Secrets manually or via Makefile target.
# For staging/prod: use SealedSecrets or External Secrets Operator.
secrets:
  # Name of the Secret containing environment variables
  # The Secret must exist in the same namespace (apps) and contain keys like:
  # DATABASE_URL, REDIS_URL, JWT_SECRET, FIREBASE_CONFIG, etc.
  envSecretName: api-env
  # Whether to inject secret as environment variables (true) or volume mount (false)
  injectAsEnv: true

# Environment variable overrides for development (non-sensitive values only)
# Sensitive values must come from secrets above.
env: {}
  # DJANGO_DEBUG: "false"
  # LOG_LEVEL: "info"

# Database connection settings for the wait-for-db init container
db:
  host: postgres
  port: 5432
  user: postgres
  # Whether to wait for the database to be ready before starting the application
  waitForDB: true

# Pod affinity rules
affinity: {}
